const express     = require('express');
const qs          = require('qs');
const url         = require('url');
const logger      = require('../lib/log');
const modelParser = require('../lib/modelParser');
const thinky      = require('../lib/thinky');
const { pp }      = require('../lib/utils');
const errors      = require('../errors');

const log = logger(module);
const r   = thinky.r;

/**
 * Converts a JSON object to a RethinkDB call
 * @param  {Object}   obj The RethinkDB model
 * @param  {Function} onFail Called if any search object is malformed
 * @return {Array<Object>} The AST generated by RethinkDB
 */
function objToRethinkDBSearch(obj, onFail) {
    if (!obj.hasOwnProperty('field')) {
        onFail();

        return [null, null];
    }

    if (!(obj.hasOwnProperty('startsWith') || obj.hasOwnProperty('endsWith') || obj.hasOwnProperty('matches') ||
        obj.hasOwnProperty('gt') || obj.hasOwnProperty('ne') || obj.hasOwnProperty('lt') ||
        obj.hasOwnProperty('ge') || obj.hasOwnProperty('le') || obj.hasOwnProperty('eq'))) {
        onFail();

        return [null, null];
    }

    let rethinkSearch = r.row(obj.field.toString());
    let outputLog     = `r.row("${obj.field.toString()}")`;

    if (obj.hasOwnProperty('startsWith')) {
        rethinkSearch = rethinkSearch.match(`^${obj.startsWith.toString()}`);
        outputLog     += `.match("^${obj.startsWith.toString()}")`;
    }

    if (obj.hasOwnProperty('endsWith')) {
        rethinkSearch = rethinkSearch.match(`${obj.endsWith.toString()}$`);
        outputLog     += `.match("${obj.endsWith.toString()}$")`;
    }

    if (obj.hasOwnProperty('matches')) {
        rethinkSearch = rethinkSearch.match(obj.matches.toString());
        outputLog     += `.match("${obj.matches.toString()}")`;
    }

    if (obj.date) {
        for (const op of ['gt', 'ne', 'lt', 'ge', 'le', 'eq']) {
            if (obj.hasOwnProperty(op)) {
                obj[op] = new Date(obj[op]);
            }
        }
    }

    if (obj.hasOwnProperty('gt')) {
        rethinkSearch = rethinkSearch.gt(obj.gt);
        outputLog     += `.gt("${obj.gt}")`;
    }

    if (obj.hasOwnProperty('ne')) {
        rethinkSearch = rethinkSearch.ne(obj.ne);
        outputLog     += `.ne("${obj.ne}")`;
    }

    if (obj.hasOwnProperty('lt')) {
        rethinkSearch = rethinkSearch.lt(obj.lt);
        outputLog     += `.lt("${obj.lt}")`;
    }

    if (obj.hasOwnProperty('ge')) {
        rethinkSearch = rethinkSearch.ge(obj.ge);
        outputLog     += `.ge("${obj.ge}")`;
    }

    if (obj.hasOwnProperty('le')) {
        rethinkSearch = rethinkSearch.le(obj.le);
        outputLog     += `.le("${obj.le}")`;
    }

    if (obj.hasOwnProperty('eq')) {
        rethinkSearch = rethinkSearch.eq(obj.eq);
        outputLog     += `.eq("${obj.eq}")`;
    }

    return [outputLog, rethinkSearch];
}

/**
 * Matches an array of search objects to a filter using « and » operator
 * @param  {Array<Object>} array  The search object
 * @param  {Function} onFail Called if any search object is malformed
 * @return {Array<Object>} The AST generated by RethinkDB
 */
function arrayToRethinkFilters(array, onFail) {
    let rethinkSearch = r;
    let outputLog     = '';
    array.forEach((searchObj, i) => {
        // First call, do not call and
        const [subLog, subSearch] = objToRethinkDBSearch(searchObj, onFail);

        if (subSearch === null) {
            return [null, null];
        }

        if (i !== 0) {
            rethinkSearch = rethinkSearch.and(subSearch);
            outputLog     += `.and(${subLog})`;
        } else {
            rethinkSearch = subSearch;
            outputLog     += subLog;
        }
    });

    return [outputLog, rethinkSearch];
}

/**
 * Match an array of array of search objects to a filter using « or » operator
 * @param  {Array<Array<Object>>} array  The search object
 * @param  {Function}   onFail Called if any search object is malformed
 * @return {Array<Object>} The AST generated by RethinkDB
 */
function arrayOfArrayToRethinkFilters(array, onFail) {
    let rethinkSearch = r;
    let outputLog     = '';
    array.forEach((searchObj, i) => {
        // First call, do not call or
        const [subLog, subSearch] = arrayToRethinkFilters(searchObj, onFail);

        /* istanbul ignore next */
        if (subSearch === null) {
            return [null, null];
        }

        if (i !== 0) {
            rethinkSearch = rethinkSearch.or(subSearch);
            outputLog     += `.or(${subLog})`;
        } else {
            rethinkSearch = subSearch;
            outputLog     += subLog;
        }
    });

    return [outputLog, rethinkSearch];
}

/**
 * Search among all documents of a model.
 */
const router = new express.Router();

router.get('/:model/search', (req, res, next) => {
    // Support encoded JSON (express doesn't)
    const q = qs.parse(url.parse(req.url).query).q;

    if (!q) {
        return next(new APIError(400, 'Missing q parameter'));
    }

    let searchQuery;

    try {
        searchQuery = (Array.isArray(q)) ? q.map(subQ => JSON.parse(subQ)) : JSON.parse(q);
    } catch (e) {
        /* istanbul ignore next */
        return next(new APIError(400, 'Invalid search object', e));
    }

    if (!Array.isArray(searchQuery)) {
        searchQuery = [searchQuery];
    }

    let orQuery     = qs.parse(url.parse(req.url).query).or || [];
    orQuery = orQuery.map(orItem => [JSON.parse(orItem)]);

    searchQuery = [searchQuery];
    searchQuery.push(...orQuery);

    let queryLog = `${req.Model}.filter(`;

    // Must use a boolean variable because we want to stop the request if failed
    let failed = false;

    const [logFilter, filterResult] = arrayOfArrayToRethinkFilters(searchQuery, () => {
        failed = true;
    });

    queryLog += logFilter;

    if (failed) {
        return next(new APIError(400, 'Invalid search object'));
    }

    let request = req.Model;

    queryLog += ')';

    // Order
    if (req.query.orderBy) {
        if (req.query.sort === 'asc') {
            // Order ASC
            queryLog += `.orderBy({ index: r.asc(${req.query.orderBy}) })`;
            request = request.orderBy({
                index: r.asc(req.query.orderBy)
            });
        } else if (req.query.sort === 'dsc') {
            // Order DSC
            queryLog += `.orderBy({ index: r.desc(${req.query.orderBy})})`;
            request = request.orderBy({
                index: r.desc(req.query.orderBy)
            });
        } else {
            // Order Default
            queryLog += `.orderBy({ index: ${req.query.orderBy} })`;
            request = request.orderBy({
                index: req.query.orderBy
            });
        }
    }

    request = request.filter(filterResult);

    // Limit
    if (req.query.limit) {
        queryLog += `.limit(${req.query.limit})`;
        request = request.limit(req.query.limit);
    }

    // Skip/Offset
    if (req.query.offset) {
        queryLog += `.skip(${req.query.offset})`;
        request = request.skip(req.query.offset);
    }

    // Embed multiple relatives
    if (req.query.embed) {
        queryLog += `.getJoin(${pp(req.query.embed)})`;
        request = request.getJoin(req.query.embed);
    }

    log.info(queryLog);

    request
        .run()
        .then((result) => {
            res
                .status(200)
                .json(result)
                .end();
        })
        .catch(thinky.Errors.DocumentNotFound, (err) => {
            /* istanbul ignore next */
            next(new APIError(404, 'Document not found', err));
        })
        .catch((err) => {
            /* istanbul ignore next */
            next(new APIError(500, 'Unknown error', err));
        });
});

router.param('model', modelParser);

module.exports = router;
